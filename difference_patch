79d78
< #include<abt.h>
98,100d96
< //#define ABT_MUTEX_INITIALIZER { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }#
< #define DEFAULT_NUM_XSTREAMS MAX_CPU_NUMBER
< #define  DEFAULT_NUM_THREADS MAX_CPU_NUMBER
121d116
< 
123,124d117
< /*ABT_mutex_memory  server_lock_memory    = ABT_MUTEX_INITIALIZER;
< ABT_mutex server_lock = ABT_MUTEX_MEMORY_GET_HANDLE(&server_lock_memory);*/
125a119,120
> #elif defined(USE_PTHREAD_SPINLOCK)
> static pthread_spinlock_t  server_lock = 0;
133,136c128
< //static pthread_t       blas_threads [MAX_CPU_/bNUMBER];
< static ABT_xstream      xstreams [MAX_CPU_NUMBER];
< static ABT_pool         pools    [MAX_CPU_NUMBER];
< static ABT_thread       blas_threads [MAX_CPU_NUMBER];
---
> static pthread_t       blas_threads [MAX_CPU_NUMBER];
147,152c139,140
< //  ABT_mutex	 lock;
<   //ABT_cond	 wakeup;
<   pthread_mutex_t        lock;
<   pthread_cond_t         wakeup;
< } thread_status_t;
< 
---
>   pthread_mutex_t	 lock;
>   pthread_cond_t	 wakeup;
153a142
> } thread_status_t;
162a152,153
> 
> 
342c333
< ABT_thread thread = (thread_idx == active_threads - 1)
---
>   pthread_t thread = (thread_idx == active_threads - 1)
396,397c387
< 	ABT_thread_yield();//Rose 
< 	//YIELDING;
---
> 	YIELDING;
403,404c393
< 	    //ABT_mutex_lock  (thread_status[cpu].lock);
< 	     pthread_mutex_lock  (&thread_status[cpu].lock);
---
> 	    pthread_mutex_lock  (&thread_status[cpu].lock);
413,414c402
< 	      //ABT_cond_wait(thread_status[cpu].wakeup, thread_status[cpu].lock);
< 	     pthread_cond_wait(&thread_status[cpu].wakeup, &thread_status[cpu].lock);
---
> 	      pthread_cond_wait(&thread_status[cpu].wakeup, &thread_status[cpu].lock);
416,417c404
< 	    //ABT_mutex_unlock(thread_status[cpu].lock);
< 	     pthread_mutex_unlock(&thread_status[cpu].lock);
---
> 	    pthread_mutex_unlock(&thread_status[cpu].lock);
630c617
<   //Rose: pthread_attr_t attr;
---
>   pthread_attr_t attr;
634,635c621,622
< //Rose:
< /*#ifdef NEED_STACKATTR
---
> 
> #ifdef NEED_STACKATTR
639c626
< #endif*/
---
> #endif
641,642c628
<   //ABT_mutex_lock(server_lock);
<    LOCK_COMMAND(&server_lock);
---
>   LOCK_COMMAND(&server_lock);
652,662d637
<     int argc; char **argv;
<     
<     
<      ABT_init(argc,argv);
<      ABT_xstream_self(&xstreams[0]);
<         for (i = 1; i < blas_num_threads - 1 ; i++) {
<                 ABT_xstream_create(ABT_SCHED_NULL, &xstreams[i]);
<         }
<         for ( i = 0; i < blas_num_threads  - 1; i++) {
<                 ABT_xstream_get_main_pools(xstreams[i], 1, &pools[i]);
<         }
664d638
<   
667d640
< 	int pool_id=i;
671,673c644
<       //ABT_mutex_create(&thread_status[i].lock);
<       //ABT_cond_create (&thread_status[i].wakeup);
<        pthread_mutex_init(&thread_status[i].lock, NULL);
---
>       pthread_mutex_init(&thread_status[i].lock, NULL);
676d646
< 
678,684c648,649
<       //ret=pthread_create(&blas_threads[i], &attr,
< 	//	     &blas_thread_server, (void *)i);
< 	  
<           
< 	  ret=ABT_thread_create(pools[pool_id],(void *)blas_thread_server, (void *)i, &attr,
<                      &blas_threads[i]);
< 
---
>       ret=pthread_create(&blas_threads[i], &attr,
> 		     &blas_thread_server, (void *)i);
686,690c651,652
<       //ret=pthread_create(&blas_threads[i], NULL,
< 	//
< 	//	     &blas_thread_server, (void *)i);
< 	  ret=ABT_thread_create(pools[pool_id],(void *)blas_thread_server, (void *)i, ABT_THREAD_ATTR_NULL,
<                      &blas_threads[i]);
---
>       ret=pthread_create(&blas_threads[i], NULL,
> 		     &blas_thread_server, (void *)i);
692d653
< 
708d668
<       
710,711c670,671
< //Rose
< /*#ifdef MONITOR
---
> 
> #ifdef MONITOR
714c674
< #endif*/
---
> #endif
717d676
<    
720d678
<   //ABT_mutex_unlock(server_lock);
721a680
> 
736c695
<   
---
> 
739,741c698
<   if (unlikely(blas_server_avail == 0)) {blas_thread_init();
< 	
<   }
---
>   if (unlikely(blas_server_avail == 0)) blas_thread_init();
830,831c787
< 	//ABT_mutex_lock  (thread_status[pos].lock);
< 	 pthread_mutex_lock  (&thread_status[pos].lock);
---
> 	pthread_mutex_lock  (&thread_status[pos].lock);
842,843c798
< 	    //ABT_cond_signal(thread_status[pos].wakeup);
< 	     pthread_cond_signal(&thread_status[pos].wakeup);
---
> 	    pthread_cond_signal(&thread_status[pos].wakeup);
847d801
< 	 // ABT_mutex_unlock(thread_status[pos].lock);
852a807
> 
857d811
< 
866,867c820
< 	ABT_thread_yield();
< 	//YIELDING;
---
> 	YIELDING;
885a839
> 
888,890c842
<   if (unlikely(blas_server_avail == 0)) {blas_thread_init();
< 	
<   }
---
>   if (unlikely(blas_server_avail == 0)) blas_thread_init();
930c882
<     } else{
---
>     } else
933c885
<     }
---
> 
939a892
> 
948a902
> 
954a909
> 
957,958c912
<   if (unlikely(blas_server_avail == 0)){ blas_thread_init();
<  }
---
>   if (unlikely(blas_server_avail == 0)) blas_thread_init();
961a916
> 
973a929
> 
978,979c934
<     //ABT_mutex_lock(server_lock);
<      LOCK_COMMAND(&server_lock);
---
>     LOCK_COMMAND(&server_lock);
983,993d937
<         /*ABT_xstream_self(&xstreams[0]);
<         for (int i = 1; i < DEFAULT_NUM_XSTREAMS; i++) {
<                 ABT_xstream_create(ABT_SCHED_NULL, &xstreams[i]);
<         }
<         for (int i = 0; i < DEFAULT_NUM_XSTREAMS; i++) {
<                 ABT_xstream_get_main_pools(xstreams[i], 1, &pools[i]);
<         }*/
< 
< 
< 
< 
995c939
< 	int pool_id=i;
---
> 
999,1000d942
<       //ABT_mutex_create(&thread_status[i].lock);
<       //ABT_cond_create (&thread_status[i].wakeup);
1004d945
< 
1006,1010c947,948
< //      pthread_create(&blas_threads[i], &attr,
< //		     &blas_thread_server, (void *)i);
<       ABT_thread_create(pools[pool_id],(void *)blas_thread_server, (void *)i, &attr,
<                      &blas_threads[i]);
< 
---
>       pthread_create(&blas_threads[i], &attr,
> 		     &blas_thread_server, (void *)i);
1012,1016c950,951
<   //    pthread_create(&blas_threads[i], NULL,
< //		     &blas_thread_server, (void *)i);
< 		     ABT_thread_create(pools[pool_id],(void *)blas_thread_server, (void *)i, ABT_THREAD_ATTR_NULL,
<                      &blas_threads[i]);
< 
---
>       pthread_create(&blas_threads[i], NULL,
> 		     &blas_thread_server, (void *)i);
1022d956
<     //ABT_mutex_unlock(server_lock);
1024d957
< 
1038c971
<   //set parametes for different number of threads.
---
>   //set parameters for different number of threads.
1046,1047d978
< 	//DEFAULT_NUM_THREADS=num_threads;
< 	//num_threads=DEFAULT_NUM_THREADS;
1092a1024
> 
1097d1028
<   //ABT_mutex_lock(server_lock);
1100d1030
< 
1104d1033
<     //ABT_mutex_lock (thread_status[i].lock);
1109,1112c1038,1040
<     //ABT_cond_signal (thread_status[i].wakeup);
<      pthread_cond_signal(&thread_status[i].wakeup);
<      pthread_mutex_unlock(&thread_status[i].lock);
<     //ABT_mutex_unlock(thread_status[i].lock);
---
>     pthread_cond_signal (&thread_status[i].wakeup);
> 
>     pthread_mutex_unlock(&thread_status[i].lock);
1114,1119d1041
<   }
< // Changed the thread count : Roja
<  
<   for (i = 0; i < blas_num_threads - 1; i++) {
< 	  ABT_thread_join(blas_threads[i]);
< 	  ABT_thread_free(&blas_threads[i]);
1122,1124c1044,1045
<   for (i = 1; i < blas_num_threads - 1 ; i++) {
< 	  ABT_xstream_join(xstreams[i]);
< 	  ABT_xstream_free(&xstreams[i]);
---
>   for(i = 0; i < blas_num_threads - 1; i++){
>     pthread_join(blas_threads[i], NULL);
1126c1047
<    //ABT_finalize();
---
> 
1128,1140c1049,1055
< 	 // ABT_mutex_free(&thread_status[i].lock);
< 	 // ABT_cond_free (&thread_status[i].wakeup);
< 	  pthread_mutex_destroy(&thread_status[i].lock);
<           pthread_cond_destroy (&thread_status[i].wakeup);
< 
<   } 
<   
<    
<   ABT_finalize();
< 
< /*#ifdef NEED_STACKATTR
< n  pthread_attr_destory(&attr);
< #endif*/
---
>     pthread_mutex_destroy(&thread_status[i].lock);
>     pthread_cond_destroy (&thread_status[i].wakeup);
>   }
> 
> #ifdef NEED_STACKATTR
>   pthread_attr_destory(&attr);
> #endif
1144d1058
<  // ABT_mutex_unlock(server_lock);
1145a1060
> 
